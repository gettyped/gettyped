#+TITLE:        type : Maybe
#+AUTHOR:       Jeremy Hughes
#+EMAIL:        jedahu@gmail.com
#+DATE:         <2016-08-07 Sun> 

#+INCLUDE: _nav.org

* Introduction                                                        :notoc:
:PROPERTIES:
:HTML_CONTAINER_CLASS: hide
:END:
#+NAME: motivation
#+BEGIN_MOTIVATION
- Handle optional values without guessing and without exceptions
- Maintain type invariants in smart constructors
#+END_MOTIVATION

~Maybe~ guarantees exception free and guess free optional value handling by
providing only one function for getting at the optional value, a function that
requires function arguments that handle both present and absent states.

* Implementation
Values of src_scala{Maybe[A]} either contain a single value of ~A~ or nothing.
#+NAME: maybe-type
#+BEGIN_SRC scala
  sealed abstract class Maybe[A]
#+END_SRC

It is usually implemented as a sum type with nullary and 1-ary “cases”.
#+NAME: sum-cases
#+BEGIN_SRC scala
  private final case class Nothing[A]() extends Maybe[A] {}

  private final case class Just[A](a: A) extends Maybe[A] {}
#+END_SRC

Since it makes no sense to have src_scala{Nothing[A]} and src_scala{Some[A]}
types available, we’ll make them private and provide two constructor functions.

#+NAME: constructors
#+BEGIN_SRC scala
  object Maybe {
    def nothing[A]: Maybe[A] = Nothing()

    def just[A](a: A): Maybe[A] = Just(a)
  }
#+END_SRC

There is only one method with access to the private internals of
src_scala{Maybe[A]}.

#+NAME: fold
#+BEGIN_SRC scala
  def fold[B](b: => B, f: A => B): B = this match {
    case Nothing() => b
    case Just(a)   => f(a)
  }
#+END_SRC

There is no way to dereference the Maybe-wrapped value directly. ~fold~ ensures
that the ~Nothing~ case is handled.

Here’s the complete definition.

#+NAME: Maybe
#+BEGIN_SRC scala
  <<maybe-type>> {
    <<fold>>
  }

  <<sum-cases>>

  <<constructors>>
#+END_SRC

#+BEGIN_SRC scala :tangle ../../scala/src/Maybe.scala :exports none
  package gettyped

  <<Maybe>>
#+END_SRC

#+BEGIN_SRC scala :tangle ../../scala-fiddle/Maybe.scala :exports none
  <<Maybe>>

  object ScalaJSExample extends js.JSApp {
    def main(): Unit = {
      println("Compile success")
    }
  }
#+END_SRC

* Maybe vs null checks
Assuming the following values:

#+BEGIN_SRC purescript
  absent :: b
  present :: a -> b
#+END_SRC

A typical null-check,

#+BEGIN_SRC purescript
  if a == null then absent else present a
#+END_SRC

exhibits a lack of type safety in two ways:

- assumption ::
     The programmer assumes ~a~ is not ~null~ and doesn’t write the null check.
- boolean blindness ::
     The compiler doesn’t stop accidental dereferencing, as in this
     transposition:
     #+BEGIN_SRC purescript
       if a == null then present a else absent
     #+END_SRC

Boolean blindness is [[bb][well described by Robert Harper]]. Here’s the money quote:

#+LINK: bb https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
     
#+BEGIN_QUOTE
Another harm is the condition of Boolean blindness alluded to earlier. Suppose
that I evaluate the expression e=e’ to test whether e and e’ are equal. I have
in my hand a bit. The bit itself has no intrinsic meaning; I must associate a
provenance with that bit in order to give it meaning. “This bit being true
means that e and e’ are equal, whereas this other bit being false means that
some other two expressions are not equal.” Keeping track of this information
(or attempting to recover it using any number of program analysis techniques) is
notoriously difficult. The only thing you can do with a bit is to branch on it,
and pretty soon you’re lost in a thicket of if-the-else’s, and you lose track
of what’s what. Evolve the program a little, and you’re soon out to sea, and
find yourself in need of sat solvers to figure out what the hell is going on.
#+END_QUOTE

~Maybe~ solves both issues.

- assumption ::
     The programmer cannot get at the value of a ~Maybe~ without going through
     ~foldMaybe~.
- boolean blindness ::
     ~foldMayb~ provides a value only to the ~just~ case:
     #+BEGIN_SRC purescript
       foldMaybe absent present a
     #+END_SRC
     An accidental transposition results in a compile time error:
     #+BEGIN_SRC purescript
       foldMaybe present absent a
       -- error: expected arg types: b     , a -> b, Maybe a
       --                       got: a -> b, b     , Maybe a
     #+END_SRC

* Smart constructors and invariants
~Maybe~ can be used to enforce a type’s invariants. A trivial example is a type
for integers greater than zero.

- ~Natural~ ::
     The type of integers ~> 0~.
- ~natural :: Int -> Maybe Natural~ ::
     The only constructor for ~Natural~ values. It returns ~nothing~ if its
     input is ~< 1~. This creates a compile time guarantee that ~Natural~ values
     will always be ~> 0~.

* Links
- [[https://wiki.haskell.org/Maybe][Haskell’s Maybe]]
- [[https://doc.rust-lang.org/std/option/][Rust’s option]]
- [[https://fsharpforfunandprofit.com/posts/the-option-type/][F#’s Option]]
- [[https://en.wikipedia.org/wiki/Option_type][Wikipedia on Option types]]
